initSidebarItems({"enum":[["Iter","An iterator specifically for iterating `edn::ValueAndSpan` instances in various ways."]],"fn":[["any_keyword",""],["any_keyword_",""],["backward_namespaced_keyword",""],["backward_namespaced_keyword_",""],["forward_any_keyword",""],["forward_any_keyword_",""],["forward_namespaced_keyword",""],["forward_namespaced_keyword_",""],["integer",""],["integer_",""],["is_valid_keyword_map_k_v","A `[k v]` pair in the map form of a keyword map must have the shape `[:k, [v1, v2, ...]]`, with none of `v1`, `v2`, ... a keyword: without loss of generality, we cannot represent the case where `vn` is a keyword `:l`, since `[:k v1 v2 ... :l]`, isn't a valid keyword map in vector form.  This function tests that a `[k v]` pair obeys these constraints."],["keyword_map",""],["keyword_map_",""],["list",""],["list_",""],["map",""],["map_",""],["namespaced_keyword",""],["namespaced_keyword_",""],["of_exactly",""],["seq",""],["seq_",""],["vector",""],["vector_","Shorthands, just enough to convert the `mentat_db` crate for now.  Written using `Box` for now: it's simple and we can address allocation issues if and when they surface."]],"struct":[["OfExactly","`OfExactly` and `of_exactly` allow us to express nested parsers naturally."],["SpanPosition","A wrapper to let us order `edn::Span` in whatever way is appropriate for parsing with `combine`."],["Stream","A single `combine::Stream` implementation iterating `edn::ValueAndSpan` instances.  Equivalent to `combine::IteratorStream` as produced by `combine::from_iter`, but specialized to `edn::ValueAndSpan`."]],"trait":[["Item","Things specific to parsing with `combine` and our `Stream` that need a trait to live outside of the `edn` crate."],["OfExactlyParsing","We need a trait to define `Parser.of` and have it live outside of the `combine` crate."],["Streaming",""]]});